[{"content":"前言 作為資深玩家，當遇到沒有中文選項的遊戲時，第一反應往往是尋找漢化MOD。這些MOD的安裝方式各異，從簡單的下載安裝包到需要修改遊戲資源的複雜操作。使用過漢化的玩家都知道，有些漢化會在遊戲更新後失效(甚至需要移除)，但有些卻不受影響，這其中的差異是什麼原因造成的呢？\n對於沒有漢化MOD的遊戲，且不懂遊戲語言的玩家，還有什麼方法可以理解遊戲內容呢？\n⚠️文章內有較為簡單的遊戲解包，遊戲逆向的技術，這些技術是用來幫助我們理解遊戲的運作原理，以及漢化的手段。請勿用於不正當的用途，以及尊重知識產權。\n最近因為工作關係，需要設計一些遊戲翻譯服務，在設計的途中接觸到一些遊戲漢化手段，當中有些技術手段個人覺得值得一看，部分技術整合到自己設計的服務裏面。於是乎想寫一篇文章來介紹一下這些技術手段~\n⚠️翻譯質量問題本文章並不會詳細討論\n人工輸入加直接用翻譯服務 所謂反璞歸真，最簡單的方法就是直接使用網上翻譯服務，例如 Google Translate、DeepL等。優點是簡單，但是缺點是需要手動去輸入文本。不考慮翻譯質量，操作上也是很麻煩，需要不斷地切換遊戲和翻譯服務之間，影響遊玩體驗\n而且還有一個關鍵問題是：\n既然都不會原語言，怎麼會懂得輸入文本呢？\n為了解決上述問題，在不修改遊戲的情況下，首先可以採用OCR技術來幫助我們進行翻譯~\nOCR技術自動識別文字與翻譯 OCR技術(光學字符識別)通過截取遊戲畫面並識別其中的文字，再將識別結果傳送至翻譯服務，最後將翻譯結果以疊加或替換方式顯示在遊戲畫面上。這種方法不僅解決了\u0026quot;不懂輸入\u0026quot;的問題，同時實現了文字提取與翻譯的自動化流程，大幅提升了效率。\nOCR翻譯工具 Google Translate (Translate images) Google Translate 提供了一個非常方便的功能 \u0026ndash; Translate images，可以直接將圖片中的文字翻譯成其他語言，這項技術的原理就是透過OCR識別文字，然后再翻譯成目標語言。\n雖然在網頁版中，只提供了上傳圖片的功能，但在手機App中，則可以直接拍攝圖片甚至動態翻譯。（可以使用智能鏡頭無需拍照，然後它會自動幫你翻譯以及替換）\nTranslate images的優點是簡單易用，無需安裝任何軟件，只需要將圖片上傳到Google Translate即可。不過，缺點是需要用另一個設備開著智能鏡頭，而且翻譯結果也不會顯示在遊戲中。感覺就像：\nGenius.jpg 話雖如此，這個功能當年在我玩 3DS 的時候還是非常好用的，當時的3DS很多遊戲并沒有中文化，那時候就靠著用iPad影住3DS幫我翻譯😂\nMORT MORT 是一個免費open source的Windows OCR 翻譯工具，是一個在電腦上不錯的選擇，對比起上述的智能鏡頭，MORT無需鏡頭就可以從螢幕上攝取。我曾經早期在玩BLUE PROTOCOL使用了MORT一會（之後因爲封鎖外國ＩＰ就沒有再用了），能應付到大部分情況。\nProject地址:　https://github.com/killkimno/MORT\nMORT 支援多種翻譯服務，也可以自己implement翻譯API，以及自訂翻譯修正功能。它的使用方法也非常簡單，只需要設置 OCR 掃描區域，然後選擇翻譯服務即可。下面將簡單示範效果：\n在操作與速度上，MORT基本上可以做到即時翻譯。基本上解決了我們人工輸入的問題，並且可以自動化翻譯過程。當然，這個工具也有一些缺點，例如需要手動設置 OCR 掃描區域，如果遊戲的文字顯示位置不固定，那么都需要經常調整掃描位置。\n缺點 整體來說，OCR技術是目前最簡單的遊戲翻譯方法之一，無需修改遊戲資源，也不需要任何編程知識，只需要安裝一個OCR翻譯工具即可。\n不過，這個方法的有一些缺點，或者說是這個技術的困難：\n對於一些具有藝術風格的文字，會出現明顯識別錯誤的情況，例如下圖，MORT提取到的文字是\u0026quot;SHAD WBRINGERS\u0026quot;，而實際上是\u0026quot;SHADOWBRINGERS\u0026quot; FFXIV Shadowbringers遊戲標題 翻譯結果的顯示可能會影響遊戲的畫面顯示，或者會遮擋到遊戲，觀賞體驗會打折扣 翻譯結果溢出了遊戲視窗 OCR技術的準確性取決於遊戲畫面的清晰度和文字的大小，如果畫面模糊/文字過小/遊戲畫面變化，則可能會導致識別錯誤\n基本上缺點２和３是技術上難以解決的，那麼就有沒有其他方法可以解決這些問題呢？\n從記憶體掃描提取文字 遊戲運行時，文字內容通常會被加載到渲染對象(Render Object)的記憶體空間中，再透過渲染函數(如draw())顯示在畫面上。\n這些文字在記憶體中是以二進制的形式存儲的，這意味著我們可以通過掃描遊戲運行時的記憶體來提取這些文字。\n簡單演示 假設我們現在有以下的遊戲畫面，然后我們想提取畫面中的文字 (畫面中的字每10秒改變一次)：\n使用一些工具來掃描遊戲的記憶體 (這裏會使用CheatEngine )，首先我們直接從記憶體搜尋 This is dialogue 7. 。 這裡由於C#的特性，字符串會被編碼成UTF-16，這裡會選擇UTF-16\n接著我們會得到一個地址列表，這些開地址都是包含This is dialogue 7.的地址\n最理想的情況下是第一次搜索然後裏面的內容會跟著畫面的字變動，這樣我們就可以知道這個地址是存放著畫面中的文字的地址。然而當畫面的文字出現變動的時候，我們會發現這個地址的內容並沒有變化\n這意味著這個地址並不是存放著畫面中的文字的地址，而是這段文字的物件地址 (Object address)\n透過分析這段文字附近的記憶體我們大概知道以下的訊息：\n這段記憶體附近存在其他的對話文本，然後這裏有重複出現的Magic Number 08 FC 4D 91 80 02 00 00 (圖片中黃色圈住的部分) 紅色部分是我們的對話文本，這裡是This is dialogue 7. 然後文本前面存在一個 14 00 的數字，這個數字是這段文字的長度，20個字，這裏比原本的長度多了1個字元，觀察最後的00 0D，發現這個是[U+000D]，是\\r 從這裡我們大概猜得出這個地址是對話文本的地址，也就是String，而前面Magic Number開始部分是String的Signature，然后4 bytes后面會跟文字的長度。\n那么我們知道這段文字的對象地址 (Object address)，然後我們可以去搜尋誰指向這個地址 (who points to this address)，這樣我們就可以知道這段文字是被誰引用 (理所當然地就是渲染的對象)\n在畫面中再一次顯示This is dialogue 7.的時候進行搜尋，我們發現有2個位置會指向這個Object，稍微再等一等畫面改變 這時候我們會發現有一個位置的地址會跟著畫面中的文字變化，是另一段文字的地址，也即使是This is dialogue 10.的地址，跟著畫面中的文字相同，這意味著這個地址是存放著渲染畫面中的文字的地址。 這意味著我們可以透過上述相同的方法，首先找到這個渲染Object的Signature，然后再找出儲存文字的偏移量(Offset)，獲取文字Object的地址，再透過文字Object獲取到文字以及文字的長度，然後將其翻譯成目標語言，最後將翻譯結果顯示在遊戲畫面上。整體過程大概是這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 std::string ExtractGameText() { // 1. 搜索渲染Object void* renderObj = FindRenderObject(); // 2. 透過渲染Object偏移取得文字Object void* textObj = *(void**)((uintptr_t)renderObj + TEXT_OBJECT_OFFSET); // 3. 透過文字Object取得文字 short textLen = *(short*)((uintptr_t)textObj + 0x4); std::string gameText = ReadGameMemory((void*)((uintptr_t)textObj + 0x6), textLen); return gameText; } 可能會有人問，為什麼不順便從渲染Object修改文字呢？因為通常直接修改文字都很大機會沒有即時反應或者會出現崩潰，有些渲染Object通常為了optimize渲染流程，通常都不會故意每一frame去重複，通常會有一個變量variable (例如 isDirty)控制、又或者一些變數權限問題、caching mechanism等等，從而導致修改失效。\n不過在這個方法下，是可以直接從遊戲中提取文字，不會受到畫面清晰度和文字大小的影響。\nTataruHelper TataruHelper 是一個用於 Final Fantasy XIV 的翻譯工具，通過Sharlayan工具獲取到遊戲劇情的文字，然後將其翻譯成目標語言。\nProject地址:　https://github.com/NightlyRevenger/TataruHelper\n然後通過對TataruHelper-Sharlayan工具簡單的分析，可以看見其中他的Reader.ChatLog.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public static ChatLogResult GetChatLog(int previousArrayIndex = 0, int previousOffset = 0) { ... Signature ChatLogKey = Scanner.Instance.Locations[Signatures.ChatLogKey]; var chatPointerMap = (IntPtr)Scanner.Instance.Locations[Signatures.ChatLogKey]; if (chatPointerMap.ToInt64() \u0026lt;= 20) { return result; } List\u0026lt;List\u0026lt;byte\u0026gt;\u0026gt; buffered = new List\u0026lt;List\u0026lt;byte\u0026gt;\u0026gt;(); try { var LineCount = (uint)MemoryHandler.Instance.GetPlatformUInt(chatPointerMap); ChatLogReader.Indexes.Clear(); ChatLogReader.ChatLogPointers = new ChatLogPointers { LineCount = (uint)MemoryHandler.Instance.GetPlatformUInt(chatPointerMap), OffsetArrayStart = MemoryHandler.Instance.GetPlatformUInt(chatPointerMap, MemoryHandler.Instance.Structures.ChatLogPointers.OffsetArrayStart), OffsetArrayPos = MemoryHandler.Instance.GetPlatformUInt(chatPointerMap, MemoryHandler.Instance.Structures.ChatLogPointers.OffsetArrayPos), OffsetArrayEnd = MemoryHandler.Instance.GetPlatformUInt(chatPointerMap, MemoryHandler.Instance.Structures.ChatLogPointers.OffsetArrayEnd), LogStart = MemoryHandler.Instance.GetPlatformUInt(chatPointerMap, MemoryHandler.Instance.Structures.ChatLogPointers.LogStart), LogNext = MemoryHandler.Instance.GetPlatformUInt(chatPointerMap, MemoryHandler.Instance.Structures.ChatLogPointers.LogNext), LogEnd = MemoryHandler.Instance.GetPlatformUInt(chatPointerMap, MemoryHandler.Instance.Structures.ChatLogPointers.LogEnd), }; ... } ... } 就是透過ChatLogKey這個Signature來獲取到遊戲的對話文本對象 (Line 4)，然後再提取其相關信息 (Line 20)。\n然後到翻譯工具本體，可以看見其中FFMemoryReader.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 private async Task ChatReader() { int _previousArrayIndex = 0; int _previousOffset = 0; ChatLogResult previousPanelResults = new ChatLogResult(); while (_KeepWorking \u0026amp;\u0026amp; _KeepReading) { try { ChatLogResult readResult = Reader.GetChatLog(_previousArrayIndex, _previousOffset); _previousArrayIndex = readResult.PreviousArrayIndex; _previousOffset = readResult.PreviousOffset; if (_UseDirectReadingInternal \u0026amp;\u0026amp; _UseDirectReading) { var directDialog = Reader.GetDirectDialog(); readResult.ChatLogItems.AddRange(directDialog.ChatLogItems); ClearMessagesList(readResult, previousPanelResults, directDialog); } var chatLogEntries = readResult.ChatLogItems; if (readResult.ChatLogItems.Count \u0026gt; 0) { for (int i = 0; i \u0026lt; readResult.ChatLogItems.Count; i++) { ProcessChatMsg(readResult.ChatLogItems[i]); } } } catch (Exception e) { Logger.WriteLog(Convert.ToString(e)); } await Task.Delay(GlobalSettings.MemoryReaderDelay); } } private void ProcessChatMsg(ChatLogItem chatLogItem) { var tmpMsg = new FFChatMsg(chatLogItem.Line, chatLogItem.Code, chatLogItem.TimeStamp); _FFxivChat.Enqueue(tmpMsg); } 然后下層則負責透過ChatLogResult處理對象，提取文字交給ProcessChatMsg負責，最後交給翻譯相關的API進行翻譯，然後將翻譯結果顯示在遊戲畫面上。 這樣就可以實現即時翻譯的效果，並且不會受到畫面清晰度和文字大小的影響。\n缺點 在不考慮技術門檻的情況下，這個方法的唯一缺點就是它的翻譯結果的呈現方式缺少沉澱感，翻譯結果並不是顯示在原本的位置。那么有沒有方法可以直接修改遊戲顯示的文字呢？\n靜態修改 - 修改遊戲資源 正常情況下遊戲資源都會分別儲存在一個資源文件夾 (Assets)裡面(例如Resoruces, AssetBundle)以方便管理，然后遊戲運行時對資源目錄讀取，例如角色的對話會儲存在TextAssets\n想像一下如果角色的對話編寫再代碼裏面，如果要進行更改那麼是一件非常麻煩的事\n靜態修改是指直接再遊戲運行前，修改遊戲資源文件中的文字，有安裝過漢化MOD的經驗的話相信對這個方法並不陌生，有些MOD就是直接覆蓋遊戲的部分檔案，原理就是把已經翻譯好的資源包 (Assets) 直接覆蓋進遊戲的資源位置，然後遊戲運行時就會直接使用這些已修改的資源(漢化后的文字)。\n雖然表面表面上看就只是覆蓋資源文件，但其實這個方法的最困難的地方是如何找到資源文件夾 (Assets)、從中提取文字以及再一次封包，一般遊戲為了防止遭到修改和解包，以及optimize遊戲運行時的速度，遊戲的資源已經被打包成專用格式。\n簡單演示 就以我們上一個例子的Demo示範，假設我們有以下的TextAssets (在Resources/dialogue)，而這些TextAssets就是畫面中的文字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;Hello\u0026#34; \u0026#34;This is dialogue 1.\u0026#34; \u0026#34;This is dialogue 2.\u0026#34; \u0026#34;This is dialogue 3.\u0026#34; \u0026#34;This is dialogue 4.\u0026#34; \u0026#34;This is dialogue 5.\u0026#34; \u0026#34;This is dialogue 6.\u0026#34; \u0026#34;This is dialogue 7.\u0026#34; \u0026#34;This is dialogue 8.\u0026#34; \u0026#34;This is dialogue 9.\u0026#34; \u0026#34;This is dialogue 10.\u0026#34; } 首先我們需要找到遊戲的位置 觀察他的Data的資料夾，這個resources.assets就是我們的目標，當然無法直接打開 這時候我們需要使用一些工具來解包這個資源包，這裡會使用UABE 然後我們可以在UABE中找到我們的TextAssets，然后對其進行修改，對其進行修改然后保存，然後再將其封包回去 最後我們就可以看到修改后的結果了 ⚠️正常情況下這裡的中文字會無法顯示，這裡為了示範已經預先把中文文字字型包打進來了遊戲裏面，後面會連同動態修改的部分一起說明這些方法的一些潛在問題\n缺點 靜態修改的方法基本上解決了上述缺少沉澱感的缺點，但同帶來了一些潛在的問題\n技術含量門檻較高‌：對遊戲的資源包進行解包和封包，需要一些專業的工具和知識。顯示的Demo的是一個Unity的遊戲，因為已經有前人的工具可以使用，所以過程看起來比較簡單。但如果是其他引擎的遊戲，則需要自己去找工具或者自己寫工具來解包和封包。\n潛在的法律風險‌：不正當使用的情況下對遊戲進行解包是有機會侵犯遊戲的智慧財產權，當然如果取得遊戲官方的授權的話就沒有這方面的考量。\n‌潛在穩定性風險‌：修改遊戲檔案可能導致程式崩潰或資料遺失，需備份原始檔案。(也是為什麼有些漢化模組會特登強調備份遊戲檔案的原因)\n模組的有效性‌風險‌：使用靜態修改漢化後，如果遊戲出現更新可能會導致修改的資源文件失效，因為原本的修改的資源包被更新成官方新版本的資源包，這樣舊的資源包就會被覆蓋掉從而失效。(也是為什麼有些漢化模組有時候會著遊戲更新後失效)\n額外的延伸問題需要處理，詳情請見 7.1: 延伸\n動態修改 - Hook 動態修改是指在遊戲運行的時候，通過一些技術手段來修改遊戲的文件中的文字。這個方法的原理是通過Hook技術來攔截遊戲的渲染函數或者文字相關的函數，然後在渲染之前將文字進行翻譯。\n手法上跟上面的從記憶體掃描出文字位址類似，但這個方法的核心不是去找Object的Signature，而是去找函數 (Function)。透過找到的相關函數，然後將其Hook，從中攔截函數的參數(Function parameters)，進行翻譯以及返回翻譯結果，然后再還原去原本的函數 (Function)。\n雖然如此，這個方法的技術含量會比靜態修改高很多，因為Hook技術本身就需要一些底層的知識，一般而言通常都會使用到inline hook，如果對這個技術的原理以及實現有興趣，我建議可以觀看以下文章:\nInline Hooking for Programmers (Part 1: Introduction) Android inline hook 浅析 (如果有機會可能我都會自己實現一次，目前我都係直接使用別人已經寫好的Library)\n簡單演示 (待更新) (這部分網上已經有很多Desktop方面，暫時不提供示範，之後會開一篇文章講述如何對手機unity APK進行Hook漢化)\nBepInEx + XUnity.AutoTranslator 這裡將會介紹其中一個Unity遊戲常見的工具，BepInEx以及XUnity.AutoTranslator\nBepInEx是一個開源的Unity遊戲模組框架，支持多種遊戲引擎，並且提供了許多API來幫助開發者進行遊戲模組的開發，BepInEx其中就有提供Unity方面的Hook API。\nXUnity.AutoTranslator則是一個基於BepInEx的翻譯模組，可以自動將遊戲中的文字翻譯成目標語言。\nBepInEx XUnity.AutoTranslator 然後通過對XUnity.AutoTranslator的Hook Folder分析，可以看見其中對各種unity文字類別進行了Hook，例如TextMeshPro、NGUI、UGUI等等，我們可以直接看TextMeshProHooks.cs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 internal static class TextWindow_SetText_Hook { ... static MethodBase TargetMethod(object instance) { return AccessToolsShim.Method(UnityTypes.TextWindow.ClrType, \u0026#34;SetText\u0026#34;, new Type[] { typeof(string) }); } ... } // TextGetterCompatHooks.cs internal static class Text_text_Hook { ... static void Postfix(object __instance, ref string __result) { TextGetterCompatModeHelper.ReplaceTextWithOriginal(__instance, ref __result); } ... } TMP是Unity的其中之一的文字渲染系統，在正常的Unity C# Code，如果要更改顯示的字就會呼叫 SetText()，從中看見XUnity.AutoTranslator會對其進行Hook，從而獲取文字，然后使用ReplaceTextWithOriginal。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [MethodImpl(MethodImplOptions.NoInlining)] public static void ReplaceTextWithOriginal(object instance, ref string __result) { if (!Settings.TextGetterCompatibilityMode || IsGettingText) return; var tti = instance.GetTextTranslationInfo(); if (tti?.IsTranslated == true) { var originalAssembly = instance.GetType().Assembly; var withinGameCode = originalAssembly.IsAssemblyCsharp(); if (withinGameCode) { // If the UI element is inside Assembly-CSharp it\u0026#39;s not possible to tell if it\u0026#39;s called by game code or UI code // This happens in NGUI, in which always replacing doesn\u0026#39;t seem to cause any issues __result = tti.OriginalText; } else { // BUG: This seems to not be right, at least in the latest BepInEx5 there seems to be one less stack frame // 0. This method // 1. Postfix // 2. _Postfix // 3. Harmony-related trampoline method/MM_Detour // 4. Original method var callingMethod = new StackFrame(4).GetMethod(); var callingAssembly = callingMethod.DeclaringType?.Assembly; if (!originalAssembly.Equals(callingAssembly)) { // if the assembly is not the same, it may be call from the game or another mod, so replace __result = tti.OriginalText; } } } } 然後在這裏處理替換成原本的文字，然後再將翻譯的文字傳回去。\n優點 優點基本繼承了靜態修改的優點，並且解決了靜態修改的缺點，因為這個方法是直接在遊戲運行的時候進行翻譯，沒有對遊戲資源進行修改，翻譯文字與原文字是隔開的，所以不需要擔心遊戲更新導致的資源包失效問題。基本上遊戲沒有大改變的情況下，漢化效果是依然存在的。(也解釋了為什麼有些漢化模組不會受到遊戲更新影響)\n缺點 缺點基本上是靜態修改的缺點，並且技術難度以及deubg比起其他方法是最困難的，以下是一些Hook常見的問題：\nHook失敗：有些遊戲會對Hook進行檢測，這樣會導致Hook失敗。除此之外，在使用inine hook的時候，Hook的function如果長度不足夠，則會導致Hook失敗 (沒有足夠的長度去注入jump指令) 時機問題：遊戲運行的時候會有很多Threadd在運行，在Proxy function的時候需要注意當前在哪一個Thread，那些Function可以使用及不可以 (Access Violation Problem) 性能問題：Proxy Function如果內部執行如果過多指令，則會導致遊戲性能下降 總結 總括來說，本文介紹的四種遊戲漢化技術方法如下：\n技術方法 技術門檻 優點 缺點 OCR技術自動識別 低 即裝即用，操作簡便 識別準確度問題(e.g: 對特殊字體/藝術字的識別率低) 記憶體掃描提取 中 不受畫面品質影響 輸出位置需針對不同遊戲進行調整 靜態修改資源 高 翻譯效果最自然，完全融入遊戲界面，修改後無需持續運行翻譯程序 涉及遊戲檔案修改存在法律風險，遊戲更新會導致修改失效 動態Hook技術 高~極高 不直接修改遊戲檔案，對遊戲更新的適應性強 開發和維護成本最高，可能影響遊戲穩定性，靜態修改資源問題，Hook問題 每種方法都有各自的好處和壞處以及最適合的使用場景，根據遊戲的特性和需求選擇從而產生不同的漢化方法的。\n延伸 在這裡會簡單提及一些延伸的問題，這些問題是針對靜態修改和動態Hook的問題\n字型問題：如果遊戲預設是沒有中文的，這意味著如果我們只是簡單地修改文字是不會有效果的(會出現亂碼的情況)，如果要顯示中文的話，則需要將中文字型包打進去遊戲裏面，而至於要怎樣將字型包打進去遊戲，就是另一個問題了。 圖片問題：如果遊戲的文字是以圖片的形式顯示的話，基本上只是修改文字是沒有用的，這時候就需要將圖片的資源包提取出來，然後再進行修改，然後再將其封包回去遊戲裏面。遊戲的圖片運氣好的話可能會提供原生的圖片資源，這樣就可以直接修改圖片了，但如果沒有的話，通常都是被打包成以及壓縮了(例如DXT,ETC)，需要有額外的工作處理。 除此之外非常建議可以閱讀一下這篇文章，這篇文章基本上講述了整個漢化的工作流程：\n游戏的汉化过程是怎样的？\n後話 這篇文章是我在學習遊戲漢化的過程中，對於遊戲漢化的一些技術方法的總結。當然科技會不斷進步，這些方法也會隨著時間而改變，這篇文章只是針對目前的技術方法進行總結。希望這篇文章能夠幫助到對遊戲漢化技術手段有興趣的人。\n參考資料 Google Translate 圖片翻譯功能: https://support.google.com/translate/answer/6142483 DeepL 翻譯器: https://www.deepl.com/en/translator 維基百科 - OCR技術: https://zh.wikipedia.org/zh-tw/光學字符識別 MORT 開源項目: https://github.com/killkimno/MORT Cheat Engine 工具: https://github.com/cheat-engine/cheat-engine TataruHelper 翻譯工具: https://github.com/NightlyRevenger/TataruHelper Sharlayan 遊戲記憶體讀取工具: https://github.com/FFXIVAPP/sharlayan UABE 資源解包工具: https://github.com/SeriousCache/UABE BepInEx 模組框架: https://github.com/BepInEx/BepInEx XUnity.AutoTranslator: https://github.com/bbepis/XUnity.AutoTranslator ","date":"2025-05-05T00:26:00+08:00","image":"https://orangeegg1937.github.io/p/%E6%8A%80%E8%A1%93%E4%B8%8A%E6%BC%A2%E5%8C%96%E9%81%8A%E6%88%B2%E6%9C%89%E4%BB%80%E9%BA%BC%E6%96%B9%E6%B3%95/src/cover_hu_44858a626cbb0ac.png","permalink":"https://orangeegg1937.github.io/p/%E6%8A%80%E8%A1%93%E4%B8%8A%E6%BC%A2%E5%8C%96%E9%81%8A%E6%88%B2%E6%9C%89%E4%BB%80%E9%BA%BC%E6%96%B9%E6%B3%95/","title":"技術上，漢化遊戲有什麼方法？"},{"content":"Giscus留言系統測試 https://giscus.app/zh-TW\n歡迎在下方留言！🤗\n","date":"2025-05-03T18:21:00+08:00","permalink":"https://orangeegg1937.github.io/p/giscus%E7%95%99%E8%A8%80%E7%B3%BB%E7%B5%B1%E6%B8%AC%E8%A9%A6/","title":"Giscus留言系統測試"},{"content":"Data types Type Description Size (bytes) Size (bits) V void 0 0 Z boolean 1 1 B byte 1 8 S short 2 16 C char 2 16 I int 4 32 J long 8 64 F float 4 32 D double 8 64 L reference 4 32 For object, it will follow the class definition in the .class file. For example, a class android.widget.TextView will be Landroid/widget/TextView; in Smali.\nFor array, it will adding a [ in front of the type, number of [ is the dimension of the array. For example, a int[] will be [I in Smali; a int[][] will be [[I.\nRegister and variable/member For all registers, the size of the register is 4 bytes (32 bits).\nParameter register and non-parameter register Size Prefix Parameter register no. of param p (e.g: p0, p1, p2, \u0026hellip;) non-parameter register .locals [num] / .registers [total] - no. of param v (e.g: v0, v1, v2, \u0026hellip;) For Parameter register, in non-static method, the first parameter register is p1, because p0 the reference to the object (p0 = this). In static method, the first parameter register is p0.\nInitialize local variable with immediate value const(/4/16) {reg}, {value}. For 64-bit, use const-wide.\nComplier may optimize the const to a smaller value. Like int i = 0 may be optimized to const/4 v0, 0x0.\nFor example, we want to initialize a = 10.\n1 const/16 v0, 0xa Constant Member/Field const-string {reg}, {string}.\nNaming When a method is invoked, the parameters to the method are placed into the last n registers.\nConsider the following method:\n1 2 3 4 5 // obj1.java int add_magic(int a, int b) { if (a \u0026gt; 10) return a + b; return 0; } Smali code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # obj1.java .method private add_magic(II)I .locals 1 const/16 v0, 0xa if-le p1, v0, :cond_0 add-int/2addr p1, p2 goto :goto_0 :cond_0 const/4 p1, 0x0 :goto_0 return p1 .end method In this example, we known that\nRegister Param/Var name in method v0 c p0 this p1 a p2 b Method Basic definition:\n1 2 # ObjectName;-\u0026gt;MethodName(ParameterTypes)ReturnType Lpackage/name/obj1;-\u0026gt;get(III)Z It is equal to the following in java:\n1 2 // obj1.java boolean get(int a, int b, int c) Method Call The basic syntax is invoke{-method-type} {parameters}, method+returnType.\nCommand Description invoke-virtual Non-private instance method invoke-static Static method invoke-direct Constructor or private method invoke-super Superclass method invoke-interface Interface method Example:\n1 2 3 4 // obj1.java public int foo(); private void bar(int a, int b); static void baz(); 1 2 3 4 # obj1.java invoke-virtual {}, Lpackage/name/obj1;-\u0026gt;foo()I invoke-direct {p0, v1, v2}, Lpackage/name/obj1;-\u0026gt;bar(II)V invoke-static {}, Lpackage/name/obj1;-\u0026gt;baz()V Assign the result of the retrun value to a variable Basic syntax is move-result [register]\nCommand Description move-result Move the return value to a register move-result-wide Move the return value to a register (64-bit) move-result-object Move the return value to a register (object) Example:\n1 2 invoke-virtual {p0}, Lpackage/name/obj1;-\u0026gt;foo()I move-result v0 Basic command for smali Variable assignment For get/put, basic syntax is {command} {src}, {dest}, {offset}.\nCommand Description Java code Smali code move Move value from one register to another a = b move v0, v1 put Assign value int a = b iput v0, p0, Lcom/example/demo/MainActivity;-\u0026gt;a:I get Get value a iget v0, p0, Lcom/example/MainActivity;-\u0026gt;a:I For get and set, there is (i/s)set/put for static variable or instance variable.\nConditional jump Syntax is if-{condition} {regA}, {regB}: {label}\nExample:\n1 2 3 4 5 6 7 // p1 = i, v0 = 10, le is less than or equal to private int add_magic(int i, int i2) { if (i \u0026lt;= 10) { // if-le p1, v0, :cond_6 return 0; } return i + i2; } Reference and detail command description Smali Github Wiki\nSmali Register\nSmali Instruction\napk 反编译基础\nSmali语法基础 - 叫我大表哥\nSmali Example (乱码三千)\n","date":"2024-10-03T14:13:00+08:00","permalink":"https://orangeegg1937.github.io/p/basic-smali-code/","title":"Basic smali code"},{"content":"Project repo here: Code 前言 話說在某一天，有位友人發送了這個貼文給我 View this post on Instagram 當時看完之后感覺幾有趣，於是自己根據這張貼文去嘗試重現出來\n分析 首先從圖片中可以大概了解當中必要的元件：MCU、顯示用的螢幕以及按鈕。\n工作原理大概就是「透過按鈕去轉換顯示在螢幕上的圖片」，因此可以分為以下幾個步驟去實現：\nHardware Setup (MCU＋螢幕) Software (顯示圖片的program) 2.1. 圖片準備 2.2. 控制按鈕去轉換圖片 Hardware Setup (MCU＋螢幕) 1x Arduino UNO 2x Button 1x SSD1306 OLED (0.96\u0026quot;) 螢幕的通訊方法這裡將會使用I2C\nSofware 因為採用SSD1306，所以可以直接用Adafruit SSD1306 Library，節省了寫I2C connection以及顯示螢幕像素的部分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define SCREEN_WIDTH 128 // OLED display width, in pixels #define SCREEN_HEIGHT 64 // OLED display height, in pixels #define OLED_RESET -1 // Reset pin # (or -1 if sharing Arduino reset pin) // Declaration for an SSD1306 display connected to I2C (SDA, SCL pins) Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, \u0026amp;Wire, OLED_RESET); // ------------------- For i2c ------------------- // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { Serial.println(F(\u0026#34;SSD1306 allocation failed\u0026#34;)); for(;;); // Don\u0026#39;t proceed, loop forever } 可能需要注意的是i2c address以及Arduino Pin位置（正常情況下應該都是0x3C）\n圖片準備 SSD1306有幾個不同尺寸的型號，根據型號的尺寸，展示圖片的範圍也會有所不同。而我所使用的尺寸是128x64，為了方便設計，圖片的原生尺寸也設定為128x64。\n然后再繪製4幅不同狀態的圖片（leftBtnOnClick, rightBtnOnClick, both, idle）\n將圖片import進去program 將圖片export變成bitmap，利用LCD Assistant輸出成byte array。（詳細的工作原理之后可能再補充一下）\n關於LCD Assistant使用方法，可以參考我在網上找到的： ＜Step By Step系列 - 番外篇 OLED圖片取檔方法, 使用LCD Assistant＞\n之後我們將結果貼上在主程式裏面 需要注意的是如果我們直接貼上的話，應該會顯示以下錯誤： 這個原因是因為Arduino的dynamic memory(RAM)沒有足夠空間放我們的圖片，dynamic memory通常在MCU上面所擁有的空間都比較少(而且珍貴)，而我們的圖片是一個非常大的檔案。\n因為我們的圖片通常是是一個常數不會變的東西，所以我們可以將圖片的資料放在Flash memory，因此我們需要加一個modifier \u0026ldquo;PROGMEM\u0026quot;在這個variable上面：\n1 const unsigned char bongoCat_idle [1024] PROGMEM = {...}; 詳細的使用可以參考官方的文章：Arduino - PROGMEM\n之后圖片就可以順利import進去program裡面了！ 按鈕控制 控制方面，可以想像成是一個簡單的state machine，望下按鈕的瞬間去render不同的圖片\n1 2 3 4 5 6 7 8 9 10 // if both button cliecked, draw both if (leftBtnState == LOW \u0026amp;\u0026amp; rightBtnState == LOW) { display.drawBitmap(0, 0, bongoCat_bothBtn, 128, 64, WHITE); } else if(leftBtnState == LOW) { display.drawBitmap(0, 0, bongoCat_leftBtn, 128, 64, WHITE); } else if(rightBtnState == LOW) { display.drawBitmap(0, 0, bongoCat_rightBtn, 128, 64, WHITE); } else { display.drawBitmap(0, 0, bongoCat_idle, 128, 64, WHITE); } 最終成果 ","date":"2024-01-20T20:28:00+08:00","image":"https://orangeegg1937.github.io/p/%E7%B0%A1%E5%96%AEbongocat%E5%8B%95%E7%95%AB-with-arduino/src/cover_hu_c901137c1bb61798.png","permalink":"https://orangeegg1937.github.io/p/%E7%B0%A1%E5%96%AEbongocat%E5%8B%95%E7%95%AB-with-arduino/","title":"簡單BongoCat動畫 with Arduino"},{"content":"UnityEvent Unity manual: https://docs.unity3d.com/Manual/UnityEvents.html\nAccording to the manual, UnityEvents are a way of allowing user driven callback to be persisted from edit time to run time without the need for additional programming and script configuration. UnityEvents may sound very unfamiliar as it cannot directly added in a gameobject. However, if you used the UGUI Button before, you will understand it soon. As the On click() selection in the button is a kind of UnityEvents.\nIf we want to use the UnityEvent, we can simply using the class UnityEvent. After that, you can see the same selection in the inspector.\nMove deeply Sometime we may want to pass some specific value to the callback function such as the enemy gameobject, however, if we look at the inspector, it dose not support to pass the gameobject, so how can we do it? Actually, we can using the generic form of the UnityEvent\u0026lt;T0\u0026gt;. Then, using .Invoke(value) to send to all listener.\nHowever, if you look at the code it may a bit complicated. So how can we assign a function into a UnityEvent without using generic? We can try to use C# delegate. Here is an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class ValueController : MonoBehaviour { private float number; private Button plus; private Button mins; public float offset = 10.0f; // initial the member private void Awake() { number = 0; plus = gameObject.transform.GetChild(0).GetComponent\u0026lt;Button\u0026gt;(); mins = gameObject.transform.GetChild(1).GetComponent\u0026lt;Button\u0026gt;(); plus.onClick.AddListener(delegate { EditVal(offset); }); mins.onClick.AddListener(delegate { EditVal(-offset); }); } private void EditVal(float val) { number += val; } } In this code, we assign the EditVal() function into the listener, when players click the plus button, the number will be increased by 10; when players click the mins button, the number will be decreased by 10. Most importantly, we havn\u0026rsquo;t create any new UnityEvent in the script.\n1 plus.onClick.AddListener(() =\u0026gt; EditVal(offset)); Or using the lambda expressions.\nThe reason why we need to use delegate/lambda expressions here because according to the Unity documentaion, the UnityAction class here (The button OnClick() ) does not take any argument.\nReference UnityEvent Class\nUnity Manual\n","date":"2023-12-03T18:21:00+08:00","permalink":"https://orangeegg1937.github.io/p/unityevent/","title":"UnityEvent"},{"content":"Leetcode 1721. Swapping Nodes in a Linked List You are given the head of a linked list, and an integer k.\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\n前言 作為一個Leetcode + Data structure菜鳥，一開始的解決方法都很直接。發現有什麼問題就直接暴力解決它。這一篇Blog最主要紀錄我前期的思考方式以及開始培養習慣，所以以下解法思路可能效率不高。\n個人解法思路 在list中先尋找第k個node為何。然後尋找它對應的node（即從尾端到開頭的第k個node），並將兩者交換。 swap實現方法相對簡單，不詳細說明 將問題簡化成「如何在list中尋找第k的node和從尾端到開頭的第k個node」 因為我們怎樣都要Travel整個Linked-list才知道整體長度（Linked-list特色），所以一開始用Array/Vector紀錄已經走過的node 透過已紀錄的Array/Vector，就知道node的位置以及整體長度，從而解決了「如何在list中尋找第k的node和從尾端到開頭的第k個node」 解法 Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapNodes(ListNode* head, int k) { vector\u0026lt;ListNode*\u0026gt; list; ListNode* curr = head; while(curr != NULL){ list.push_back(curr); curr = curr-\u0026gt;next; } int selected = k-1, mirror = list.size()-k; if(k == 1 || k == list.size() || (mirror-1 == selected) || (selected-1 == mirror)){ int temp = list[selected]-\u0026gt;val; list[selected]-\u0026gt;val = list[mirror]-\u0026gt;val; list[mirror]-\u0026gt;val = temp; }else{ list[selected-1]-\u0026gt;next = list[mirror]; list[selected]-\u0026gt;next = list[mirror+1]; list[mirror-1]-\u0026gt;next = list[selected]; list[mirror]-\u0026gt;next = list[selected+1]; } return list[0]; } }; Time complexity: $\\mathcal{O}(n)$, $\\mathcal n=number \\space of\\space nodes$\nSpace complexity: $\\mathcal{O}(n)$, $\\mathcal n=number \\space of\\space nodes$\n更進一步思考 這裏還有更加好的方法嗎？ 「怎樣都要Travel整個Linked-list才知道整體長度」→ Time complexity 已經沒有最佳化空間 → 那麼就從Space complexity改良 有沒有方法可以節省空間？有，可以用pointer紀錄兩個位置 (fast/slow point) 我們首先用fast pointer尋找第k的node curr (current) = fast pointer 然後slow fast pointer一起走 透過上圖我們發現當fast到達終點時，剛好就是我們想要的對應node的位置 解法2 Solution2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapNodes(ListNode* head, int k) { ListNode* slow = head; ListNode* fast = head; ListNode* curr; for(int i = 1; i \u0026lt; k; i++){ fast=fast-\u0026gt;next; } curr = fast; while(fast-\u0026gt;next != NULL){ slow=slow-\u0026gt;next; fast=fast-\u0026gt;next; } swap(curr-\u0026gt;val,slow-\u0026gt;val); return head; } }; Time complexity: $\\mathcal{O}(n)$, $\\mathcal n=number \\space of\\space nodes$\nSpace complexity: $\\mathcal{O}(1)$, 我們只用了三個pointer\n","date":"2023-05-15T20:41:00+08:00","permalink":"https://orangeegg1937.github.io/p/leetcode-1721-swapping-nodes-in-a-linked-list/","title":"Leetcode 1721 Swapping Nodes in a Linked List"},{"content":"絕龍詩戰爭 - Day After Clear 趁開新版本之前仲得閒寫返個通關後感，寫完發現太長，先post咗演出部分先。\n攻略時間：\n第1隊：61小時（第一隊因為某事暫停，未通關的） 第2隊：58小時 （合共119小時） 評分：\n副本演出：9/10（-1分因為某些地方竟然沒有語音） 機制難度：10/10（沒有解謎，全部硬碰硬機制） 輸出要求：8.5/10（當版），6/10（6.3後） 心理要求：8/10 綜合：9/10 副本演出 「圍繞著『假如』的幻想詩歌」絕龍詩戰爭主要圍繞著3個部分\n正史─輪迴─偽典。\n正史部分基本上就是跑完整個3.0-3.3故事流程，從教皇廳阻止教皇、經歷了好朋友Haurchefant的死亡、在魔大陸與騎神展開最終決戰，最後在雲廊討伐邪龍以及拯救大師兄，為千年龍詩畫上句號。基本上這部分機制演出在正常水平，不過當中有一個最震撼的地方就是Haurchefant出來幫你擋槍，\n輪迴則是這次副本的第一大亮點，當我們完成了正史流程，異邦的詩人會送我們回到教皇廳的時間線，我們得到一次機會去尋找可以拯救好朋友的可能性，如果玩家在時間回溯的時間仍未救下他，那我們就會再一次輪迴到正史時間線，直到找到能夠拯救他的方法。不過現在這部分在有攻略的情況下基本上一下子就打破了輪迴，但在版本初期見證住天團一次又一次的嘗試，去到最終成功救到他，那一瞬間整個整個人十分興奮和感動。回溯這部分可以說是目前只有絕龍詩才有的特色，雖然回到過去這個題材在FF14已經用到爛哂，但作為機制演出效果我會給滿分，而且也滿足不小玩家想返去拯救他的那種遺憾，非常建議大家去體驗一下。\n當玩家正沈澱在成功拯救友人的喜悅之中，殘酷的異邦詩人卻為我們彈奏了另一首悲劇的開始─偽典時間線。在偽典時間線的一開始，我們將在雲海再次與騎神戰鬥，但因為世界線的變動，當玩家趕到的時候龍族已經被騎神精煉，這一次我們面對的敵人不止蒼天騎士團還有龍族。基本上戰鬥流程沒有太大分別。不過這部分的戰鬥除了有100% match的背景音樂外，Boss的對話也十分有趣，當玩家解完至天の陣風槍後，騎神對身為光戰的我們發問：\n「憑你可以如何終結這千年戰爭？」\n而我們在完成至天の陣死刻，騎神再一次發問：\n「你以為殺掉了我就能結果了戰爭，化解了千年的恩怨嗎？」\n這時候Boss都常剩下很少血，這時候如果騎神低於3%，他會跪下來救玩家不要殺他。如果玩家選擇殺他，那麼會被後面劇情強制終結，所以為了過本，玩家只好放過他，並留下一句：\n「你會為你的天真付出代價，光之戰士。」\n不過整體來說這部分作為偽典的開頭我覺得很好，不單可以感受絕本的難度，也可以感受一下演出效果。在版本開初時很多人都以為要打死他，好像是後來有人在chat room說騎神在最後說了些甚麼，試一下不擊殺，結果發現原來會有逃走的部分。以FF14來說可以看出設計師在這個部分花多了一些心機，在機制上加多了副本演出效果。\n雖然我們放過了騎神，但偽典龍詩仍然在繼續。我們再次在雲廊與邪龍展開決戰，但這一次，被控制的聖龍也加入了戰鬥。這部分的戰鬥演出沒有十分特別的地方，很多都是以前出現過的機制。不過背景音樂用了Dragonsong，Dragonsong裏面就描述了人與龍之間的故事，從如何人與龍一起，到人背叛了龍，剛好就是這兩條龍。除此之外，這部分有一個有興的點是，聖龍身上有「不殺的誓言：聖龍赫拉斯瓦尔格吃掉深愛的希瓦時所立下的不殺誓言」的Buff，如果玩家被聖龍殺掉，那聖龍會狂暴，之後殺光我們。（只要你們死了，就不會有人知道我打破誓言）\n當光之戰士打敗雙龍後再一次準備救大師兄的時候，騎神跳了出來，乘勢對我們造成傷害並且吸收了在場的所有龍眼的力量，化身成為新的神──騎龍神。騎龍神的戰鬥與絕巴哈一樣，屬於手汗級難度，在經歷17分鐘的集中後配上管弦樂版的逆襲の咆哮和令人手震的地火機制，這部分緊張感十足。不過可能是考慮到這是這最終決戰想減少玩家的壓力和令玩家集中處理機制，從轉場到過本是零配音。\n而當玩家通關後，絕龍詩作為高難度副本罕有地加了1分鐘Ending，主要是向玩家表達龍詩戰爭的另一個可能性，拯救了一個生命但卻帶來了另一種悲劇，不要沈澱在過去而是要帶着前人的意志去開拓未來。個人覺得這部分跟6.0主線有少量相似的地方，但我並不認同選擇了一個，另一個就會死的結局，這裏應該有一個可以拯救所有人的時間線。Steins;Gate 不過這始終只是一個為HC玩家的挑戰，有時候過多的解讀可能會失去副本趣味。總括而言絕龍詩非常建議大家去體驗。\n","date":"2022-08-20T00:16:34+08:00","image":"https://pbs.twimg.com/media/FY7zPPjacAACkFF?format=jpg","permalink":"https://orangeegg1937.github.io/p/ffxiv-%E7%B5%95%E9%BE%8D%E8%A9%A9%E6%88%B0%E7%88%AD-day-after-clear/","title":"FFXIV - 絕龍詩戰爭 - Day After Clear"}]