[{"content":"Giscus留言系統測試 https://giscus.app/zh-TW\n歡迎在下方留言！🤗\n","date":"2025-05-03T18:21:00+08:00","permalink":"https://orangeegg1937.github.io/p/giscus%E7%95%99%E8%A8%80%E7%B3%BB%E7%B5%B1%E6%B8%AC%E8%A9%A6/","title":"Giscus留言系統測試"},{"content":"Data types Type Description Size (bytes) Size (bits) V void 0 0 Z boolean 1 1 B byte 1 8 S short 2 16 C char 2 16 I int 4 32 J long 8 64 F float 4 32 D double 8 64 L reference 4 32 For object, it will follow the class definition in the .class file. For example, a class android.widget.TextView will be Landroid/widget/TextView; in Smali.\nFor array, it will adding a [ in front of the type, number of [ is the dimension of the array. For example, a int[] will be [I in Smali; a int[][] will be [[I.\nRegister and variable/member For all registers, the size of the register is 4 bytes (32 bits).\nParameter register and non-parameter register Size Prefix Parameter register no. of param p (e.g: p0, p1, p2, \u0026hellip;) non-parameter register .locals [num] / .registers [total] - no. of param v (e.g: v0, v1, v2, \u0026hellip;) For Parameter register, in non-static method, the first parameter register is p1, because p0 the reference to the object (p0 = this). In static method, the first parameter register is p0.\nInitialize local variable with immediate value const(/4/16) {reg}, {value}. For 64-bit, use const-wide.\nComplier may optimize the const to a smaller value. Like int i = 0 may be optimized to const/4 v0, 0x0.\nFor example, we want to initialize a = 10.\n1 const/16 v0, 0xa Constant Member/Field const-string {reg}, {string}.\nNaming When a method is invoked, the parameters to the method are placed into the last n registers.\nConsider the following method:\n1 2 3 4 5 // obj1.java int add_magic(int a, int b) { if (a \u0026gt; 10) return a + b; return 0; } Smali code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # obj1.java .method private add_magic(II)I .locals 1 const/16 v0, 0xa if-le p1, v0, :cond_0 add-int/2addr p1, p2 goto :goto_0 :cond_0 const/4 p1, 0x0 :goto_0 return p1 .end method In this example, we known that\nRegister Param/Var name in method v0 c p0 this p1 a p2 b Method Basic definition:\n1 2 # ObjectName;-\u0026gt;MethodName(ParameterTypes)ReturnType Lpackage/name/obj1;-\u0026gt;get(III)Z It is equal to the following in java:\n1 2 // obj1.java boolean get(int a, int b, int c) Method Call The basic syntax is invoke{-method-type} {parameters}, method+returnType.\nCommand Description invoke-virtual Non-private instance method invoke-static Static method invoke-direct Constructor or private method invoke-super Superclass method invoke-interface Interface method Example:\n1 2 3 4 // obj1.java public int foo(); private void bar(int a, int b); static void baz(); 1 2 3 4 # obj1.java invoke-virtual {}, Lpackage/name/obj1;-\u0026gt;foo()I invoke-direct {p0, v1, v2}, Lpackage/name/obj1;-\u0026gt;bar(II)V invoke-static {}, Lpackage/name/obj1;-\u0026gt;baz()V Assign the result of the retrun value to a variable Basic syntax is move-result [register]\nCommand Description move-result Move the return value to a register move-result-wide Move the return value to a register (64-bit) move-result-object Move the return value to a register (object) Example:\n1 2 invoke-virtual {p0}, Lpackage/name/obj1;-\u0026gt;foo()I move-result v0 Basic command for smali Variable assignment For get/put, basic syntax is {command} {src}, {dest}, {offset}.\nCommand Description Java code Smali code move Move value from one register to another a = b move v0, v1 put Assign value int a = b iput v0, p0, Lcom/example/demo/MainActivity;-\u0026gt;a:I get Get value a iget v0, p0, Lcom/example/MainActivity;-\u0026gt;a:I For get and set, there is (i/s)set/put for static variable or instance variable.\nConditional jump Syntax is if-{condition} {regA}, {regB}: {label}\nExample:\n1 2 3 4 5 6 7 // p1 = i, v0 = 10, le is less than or equal to private int add_magic(int i, int i2) { if (i \u0026lt;= 10) { // if-le p1, v0, :cond_6 return 0; } return i + i2; } Reference and detail command description Smali Github Wiki\nSmali Register\nSmali Instruction\napk 反编译基础\nSmali语法基础 - 叫我大表哥\nSmali Example (乱码三千)\n","date":"2024-10-03T14:13:00+08:00","permalink":"https://orangeegg1937.github.io/p/basic-smali-code/","title":"Basic smali code"},{"content":"Project repo here: Code 前言 話說在某一天，有位友人發送了這個貼文給我 View this post on Instagram 當時看完之后感覺幾有趣，於是自己根據這張貼文去嘗試重現出來\n分析 首先從圖片中可以大概了解當中必要的元件：MCU、顯示用的螢幕以及按鈕。\n工作原理大概就是「透過按鈕去轉換顯示在螢幕上的圖片」，因此可以分為以下幾個步驟去實現：\nHardware Setup (MCU＋螢幕) Software (顯示圖片的program) 2.1. 圖片準備 2.2. 控制按鈕去轉換圖片 Hardware Setup (MCU＋螢幕) 1x Arduino UNO 2x Button 1x SSD1306 OLED (0.96\u0026quot;) 螢幕的通訊方法這裡將會使用I2C\nSofware 因為採用SSD1306，所以可以直接用Adafruit SSD1306 Library，節省了寫I2C connection以及顯示螢幕像素的部分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define SCREEN_WIDTH 128 // OLED display width, in pixels #define SCREEN_HEIGHT 64 // OLED display height, in pixels #define OLED_RESET -1 // Reset pin # (or -1 if sharing Arduino reset pin) // Declaration for an SSD1306 display connected to I2C (SDA, SCL pins) Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, \u0026amp;Wire, OLED_RESET); // ------------------- For i2c ------------------- // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { Serial.println(F(\u0026#34;SSD1306 allocation failed\u0026#34;)); for(;;); // Don\u0026#39;t proceed, loop forever } 可能需要注意的是i2c address以及Arduino Pin位置（正常情況下應該都是0x3C）\n圖片準備 SSD1306有幾個不同尺寸的型號，根據型號的尺寸，展示圖片的範圍也會有所不同。而我所使用的尺寸是128x64，為了方便設計，圖片的原生尺寸也設定為128x64。\n然后再繪製4幅不同狀態的圖片（leftBtnOnClick, rightBtnOnClick, both, idle）\n將圖片import進去program 將圖片export變成bitmap，利用LCD Assistant輸出成byte array。（詳細的工作原理之后可能再補充一下）\n關於LCD Assistant使用方法，可以參考我在網上找到的： ＜Step By Step系列 - 番外篇 OLED圖片取檔方法, 使用LCD Assistant＞\n之後我們將結果貼上在主程式裏面 需要注意的是如果我們直接貼上的話，應該會顯示以下錯誤： 這個原因是因為Arduino的dynamic memory(RAM)沒有足夠空間放我們的圖片，dynamic memory通常在MCU上面所擁有的空間都比較少(而且珍貴)，而我們的圖片是一個非常大的檔案。\n因為我們的圖片通常是是一個常數不會變的東西，所以我們可以將圖片的資料放在Flash memory，因此我們需要加一個modifier \u0026ldquo;PROGMEM\u0026quot;在這個variable上面：\n1 const unsigned char bongoCat_idle [1024] PROGMEM = {...}; 詳細的使用可以參考官方的文章：Arduino - PROGMEM\n之后圖片就可以順利import進去program裡面了！ 按鈕控制 控制方面，可以想像成是一個簡單的state machine，望下按鈕的瞬間去render不同的圖片\n1 2 3 4 5 6 7 8 9 10 // if both button cliecked, draw both if (leftBtnState == LOW \u0026amp;\u0026amp; rightBtnState == LOW) { display.drawBitmap(0, 0, bongoCat_bothBtn, 128, 64, WHITE); } else if(leftBtnState == LOW) { display.drawBitmap(0, 0, bongoCat_leftBtn, 128, 64, WHITE); } else if(rightBtnState == LOW) { display.drawBitmap(0, 0, bongoCat_rightBtn, 128, 64, WHITE); } else { display.drawBitmap(0, 0, bongoCat_idle, 128, 64, WHITE); } 最終成果 ","date":"2024-01-20T20:28:00+08:00","image":"https://orangeegg1937.github.io/p/%E7%B0%A1%E5%96%AEbongocat%E5%8B%95%E7%95%AB-with-arduino/src/cover_hu_c901137c1bb61798.png","permalink":"https://orangeegg1937.github.io/p/%E7%B0%A1%E5%96%AEbongocat%E5%8B%95%E7%95%AB-with-arduino/","title":"簡單BongoCat動畫 with Arduino"},{"content":"UnityEvent Unity manual: https://docs.unity3d.com/Manual/UnityEvents.html\nAccording to the manual, UnityEvents are a way of allowing user driven callback to be persisted from edit time to run time without the need for additional programming and script configuration. UnityEvents may sound very unfamiliar as it cannot directly added in a gameobject. However, if you used the UGUI Button before, you will understand it soon. As the On click() selection in the button is a kind of UnityEvents.\nIf we want to use the UnityEvent, we can simply using the class UnityEvent. After that, you can see the same selection in the inspector.\nMove deeply Sometime we may want to pass some specific value to the callback function such as the enemy gameobject, however, if we look at the inspector, it dose not support to pass the gameobject, so how can we do it? Actually, we can using the generic form of the UnityEvent\u0026lt;T0\u0026gt;. Then, using .Invoke(value) to send to all listener.\nHowever, if you look at the code it may a bit complicated. So how can we assign a function into a UnityEvent without using generic? We can try to use C# delegate. Here is an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class ValueController : MonoBehaviour { private float number; private Button plus; private Button mins; public float offset = 10.0f; // initial the member private void Awake() { number = 0; plus = gameObject.transform.GetChild(0).GetComponent\u0026lt;Button\u0026gt;(); mins = gameObject.transform.GetChild(1).GetComponent\u0026lt;Button\u0026gt;(); plus.onClick.AddListener(delegate { EditVal(offset); }); mins.onClick.AddListener(delegate { EditVal(-offset); }); } private void EditVal(float val) { number += val; } } In this code, we assign the EditVal() function into the listener, when players click the plus button, the number will be increased by 10; when players click the mins button, the number will be decreased by 10. Most importantly, we havn\u0026rsquo;t create any new UnityEvent in the script.\n1 plus.onClick.AddListener(() =\u0026gt; EditVal(offset)); Or using the lambda expressions.\nThe reason why we need to use delegate/lambda expressions here because according to the Unity documentaion, the UnityAction class here (The button OnClick() ) does not take any argument.\nReference UnityEvent Class\nUnity Manual\n","date":"2023-12-03T18:21:00+08:00","permalink":"https://orangeegg1937.github.io/p/unityevent/","title":"UnityEvent"},{"content":"Leetcode 1721. Swapping Nodes in a Linked List You are given the head of a linked list, and an integer k.\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\n前言 作為一個Leetcode + Data structure菜鳥，一開始的解決方法都很直接。發現有什麼問題就直接暴力解決它。這一篇Blog最主要紀錄我前期的思考方式以及開始培養習慣，所以以下解法思路可能效率不高。\n個人解法思路 在list中先尋找第k個node為何。然後尋找它對應的node（即從尾端到開頭的第k個node），並將兩者交換。 swap實現方法相對簡單，不詳細說明 將問題簡化成「如何在list中尋找第k的node和從尾端到開頭的第k個node」 因為我們怎樣都要Travel整個Linked-list才知道整體長度（Linked-list特色），所以一開始用Array/Vector紀錄已經走過的node 透過已紀錄的Array/Vector，就知道node的位置以及整體長度，從而解決了「如何在list中尋找第k的node和從尾端到開頭的第k個node」 解法 Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapNodes(ListNode* head, int k) { vector\u0026lt;ListNode*\u0026gt; list; ListNode* curr = head; while(curr != NULL){ list.push_back(curr); curr = curr-\u0026gt;next; } int selected = k-1, mirror = list.size()-k; if(k == 1 || k == list.size() || (mirror-1 == selected) || (selected-1 == mirror)){ int temp = list[selected]-\u0026gt;val; list[selected]-\u0026gt;val = list[mirror]-\u0026gt;val; list[mirror]-\u0026gt;val = temp; }else{ list[selected-1]-\u0026gt;next = list[mirror]; list[selected]-\u0026gt;next = list[mirror+1]; list[mirror-1]-\u0026gt;next = list[selected]; list[mirror]-\u0026gt;next = list[selected+1]; } return list[0]; } }; Time complexity: $\\mathcal{O}(n)$, $\\mathcal n=number \\space of\\space nodes$\nSpace complexity: $\\mathcal{O}(n)$, $\\mathcal n=number \\space of\\space nodes$\n更進一步思考 這裏還有更加好的方法嗎？ 「怎樣都要Travel整個Linked-list才知道整體長度」→ Time complexity 已經沒有最佳化空間 → 那麼就從Space complexity改良 有沒有方法可以節省空間？有，可以用pointer紀錄兩個位置 (fast/slow point) 我們首先用fast pointer尋找第k的node curr (current) = fast pointer 然後slow fast pointer一起走 透過上圖我們發現當fast到達終點時，剛好就是我們想要的對應node的位置 解法2 Solution2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapNodes(ListNode* head, int k) { ListNode* slow = head; ListNode* fast = head; ListNode* curr; for(int i = 1; i \u0026lt; k; i++){ fast=fast-\u0026gt;next; } curr = fast; while(fast-\u0026gt;next != NULL){ slow=slow-\u0026gt;next; fast=fast-\u0026gt;next; } swap(curr-\u0026gt;val,slow-\u0026gt;val); return head; } }; Time complexity: $\\mathcal{O}(n)$, $\\mathcal n=number \\space of\\space nodes$\nSpace complexity: $\\mathcal{O}(1)$, 我們只用了三個pointer\n","date":"2023-05-15T20:41:00+08:00","permalink":"https://orangeegg1937.github.io/p/leetcode-1721-swapping-nodes-in-a-linked-list/","title":"Leetcode 1721 Swapping Nodes in a Linked List"},{"content":"絕龍詩戰爭 - Day After Clear 趁開新版本之前仲得閒寫返個通關後感，寫完發現太長，先post咗演出部分先。\n攻略時間：\n第1隊：61小時（第一隊因為某事暫停，未通關的） 第2隊：58小時 （合共119小時） 評分：\n副本演出：9/10（-1分因為某些地方竟然沒有語音） 機制難度：10/10（沒有解謎，全部硬碰硬機制） 輸出要求：8.5/10（當版），6/10（6.3後） 心理要求：8/10 綜合：9/10 副本演出 「圍繞著『假如』的幻想詩歌」絕龍詩戰爭主要圍繞著3個部分\n正史─輪迴─偽典。\n正史部分基本上就是跑完整個3.0-3.3故事流程，從教皇廳阻止教皇、經歷了好朋友Haurchefant的死亡、在魔大陸與騎神展開最終決戰，最後在雲廊討伐邪龍以及拯救大師兄，為千年龍詩畫上句號。基本上這部分機制演出在正常水平，不過當中有一個最震撼的地方就是Haurchefant出來幫你擋槍，\n輪迴則是這次副本的第一大亮點，當我們完成了正史流程，異邦的詩人會送我們回到教皇廳的時間線，我們得到一次機會去尋找可以拯救好朋友的可能性，如果玩家在時間回溯的時間仍未救下他，那我們就會再一次輪迴到正史時間線，直到找到能夠拯救他的方法。不過現在這部分在有攻略的情況下基本上一下子就打破了輪迴，但在版本初期見證住天團一次又一次的嘗試，去到最終成功救到他，那一瞬間整個整個人十分興奮和感動。回溯這部分可以說是目前只有絕龍詩才有的特色，雖然回到過去這個題材在FF14已經用到爛哂，但作為機制演出效果我會給滿分，而且也滿足不小玩家想返去拯救他的那種遺憾，非常建議大家去體驗一下。\n當玩家正沈澱在成功拯救友人的喜悅之中，殘酷的異邦詩人卻為我們彈奏了另一首悲劇的開始─偽典時間線。在偽典時間線的一開始，我們將在雲海再次與騎神戰鬥，但因為世界線的變動，當玩家趕到的時候龍族已經被騎神精煉，這一次我們面對的敵人不止蒼天騎士團還有龍族。基本上戰鬥流程沒有太大分別。不過這部分的戰鬥除了有100% match的背景音樂外，Boss的對話也十分有趣，當玩家解完至天の陣風槍後，騎神對身為光戰的我們發問：\n「憑你可以如何終結這千年戰爭？」\n而我們在完成至天の陣死刻，騎神再一次發問：\n「你以為殺掉了我就能結果了戰爭，化解了千年的恩怨嗎？」\n這時候Boss都常剩下很少血，這時候如果騎神低於3%，他會跪下來救玩家不要殺他。如果玩家選擇殺他，那麼會被後面劇情強制終結，所以為了過本，玩家只好放過他，並留下一句：\n「你會為你的天真付出代價，光之戰士。」\n不過整體來說這部分作為偽典的開頭我覺得很好，不單可以感受絕本的難度，也可以感受一下演出效果。在版本開初時很多人都以為要打死他，好像是後來有人在chat room說騎神在最後說了些甚麼，試一下不擊殺，結果發現原來會有逃走的部分。以FF14來說可以看出設計師在這個部分花多了一些心機，在機制上加多了副本演出效果。\n雖然我們放過了騎神，但偽典龍詩仍然在繼續。我們再次在雲廊與邪龍展開決戰，但這一次，被控制的聖龍也加入了戰鬥。這部分的戰鬥演出沒有十分特別的地方，很多都是以前出現過的機制。不過背景音樂用了Dragonsong，Dragonsong裏面就描述了人與龍之間的故事，從如何人與龍一起，到人背叛了龍，剛好就是這兩條龍。除此之外，這部分有一個有興的點是，聖龍身上有「不殺的誓言：聖龍赫拉斯瓦尔格吃掉深愛的希瓦時所立下的不殺誓言」的Buff，如果玩家被聖龍殺掉，那聖龍會狂暴，之後殺光我們。（只要你們死了，就不會有人知道我打破誓言）\n當光之戰士打敗雙龍後再一次準備救大師兄的時候，騎神跳了出來，乘勢對我們造成傷害並且吸收了在場的所有龍眼的力量，化身成為新的神──騎龍神。騎龍神的戰鬥與絕巴哈一樣，屬於手汗級難度，在經歷17分鐘的集中後配上管弦樂版的逆襲の咆哮和令人手震的地火機制，這部分緊張感十足。不過可能是考慮到這是這最終決戰想減少玩家的壓力和令玩家集中處理機制，從轉場到過本是零配音。\n而當玩家通關後，絕龍詩作為高難度副本罕有地加了1分鐘Ending，主要是向玩家表達龍詩戰爭的另一個可能性，拯救了一個生命但卻帶來了另一種悲劇，不要沈澱在過去而是要帶着前人的意志去開拓未來。個人覺得這部分跟6.0主線有少量相似的地方，但我並不認同選擇了一個，另一個就會死的結局，這裏應該有一個可以拯救所有人的時間線。Steins;Gate 不過這始終只是一個為HC玩家的挑戰，有時候過多的解讀可能會失去副本趣味。總括而言絕龍詩非常建議大家去體驗。\n","date":"2022-08-20T00:16:34+08:00","image":"https://pbs.twimg.com/media/FY7zPPjacAACkFF?format=jpg","permalink":"https://orangeegg1937.github.io/p/ffxiv-%E7%B5%95%E9%BE%8D%E8%A9%A9%E6%88%B0%E7%88%AD-day-after-clear/","title":"FFXIV - 絕龍詩戰爭 - Day After Clear"}]